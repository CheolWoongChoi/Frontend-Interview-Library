# 🐶 Week 2 질문 정리

## 📚 JavaScript
### 🎈 클로저에 대해서 설명하기
- [클로저에 대한 내용을 책을 읽고 정리](https://github.com/saseungmin/reading_books_record_repository/tree/master/%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/Chapter%205)
- [이응모님의 작성글](https://poiemaweb.com/js-closure)

### 🎈 이벤트 버블링, 이벤트 캡처링, 이벤트 위임에 대해서 설명

#### 🐶 버블링
- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작한다.
- 가장 최상단의 조상 요소를 만날 때까지 이 과정을 반복되면서 요소 각각에 할당된 핸들러가 동작한다.
- 이벤트가 제일 깊은 곳에 있는 요소에서 시작해 부모 요소를 거슬러 올라가며 발생한다.

#### 🐶 버블링

- https://ko.javascript.info/bubbling-and-capturing

#### 🐶 이벤트 위임
- 이벤트 위임은 비슷한 방식으로 여러 요소를 다뤄야 할 때 사용된다. 
- 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않고, 요소의 공통 조상에 이벤트 핸들러를 단 하나만 할당해도 여러 요소를 한꺼번에 다룰 수 있다.
- 이벤트 위임의 장점
  - 많은 핸들러를 할당하지 않아도 되기 때문에 초기화가 단순해지고 메모리가 절약된다.
  - 요소를 추가하거나 제거할 때 해당 요소에 할당된 핸들러를 추가하거나 제거할 필요가 없기 때문에 코드가 짧아진다.
- 이벤트 위임 단점
  - 이벤트 위임을 사용하려면 이벤트가 반드시 버블링 되어야 한다.
- https://ko.javascript.info/event-delegation

## 📚 Web
### 🎈 HTTP와 HTTPS의 차이점은?

#### 🐶 HTTP
- HTTP란 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜이다.
- 즉, HTTP는 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로 80번 포트를 사용하고 있다.
- HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며, Method(GET, POST..), Path, Version (HTTP/1.1), Headers, Body등으로 구성된다.
- HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제 3자가 정보를 조회할 수 있다. 그렇기에 HTTPS가 등장하게 되었다.

#### 🐶 HTTPS
- HTTP에 데이터 암호화가 추가된 프로토콜이다. HTTPS는 443번 포트를 사용하며, 네트워크 상에서 중간에 제 3자가 정보를 볼 수 없도록 공개키 암호화를 지원하고 있다.
  - 공개키로 암호화를 하면 개인키로만 복호화할 수 있다. -> 개인키는 나만 가지고 있으므로, 나만 볼 수 있다.
- HTTPS는 SSL과 같은 프로토콜을 사용하여 공개키/개인키 기반으로 데이터를 암호화하고 있다.

#### 🐶 차이점
- HTTP는 암호화가 추가되지 않기 때문에 보안에 취약한 반볌, HTTPS는 안전하게 데이터를 주고받을 수 있다. 하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 떄문에 HTTP보다 속도가 상대적으로 느리지만, 오늘날에는 거의 차이를 못느낀다. 또한 HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생한다.
- [참고](https://mangkyu.tistory.com/98)

### 🎈 쿠키(cookie)와 세션(session)의 차이점은?

#### 🐶 쿠키와 세션의 사용이유
- 쿠키와 세션을 사용하는 이유는 HTTP 프로토콜의 약점을 보안하기 위해서 사용되는데 HTTP는 비연결지향적이고 상태정보를 유지하지 않기 떄문에 서버는 클라이언트가 누구인지 계속 인증을 해줘야 한다.
- 하지만 매우 번거롭기뿐만 아니라 웹페이지의 로딩을 느리게 만든다. 그래서 쿠키와 세션을 이용하여 클라이언트의 정보 유지를 할 수 있다.

#### 🐶 쿠키란
- HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 **사용자의 컴퓨터에 저장하는 작은 기록 정보 파일**이다.
- HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 필요시 정보를 참조하거나 재사용할 수 있다.
- 쿠키는 클라이언트에 총 300개의 쿠키 저장 및 하나의 도메인 당 20개의 쿠키를 가질 수 있다.
- 사용 예시로는 다시 방문 하였을 때 아이디 정보 저장, 오늘 이 창을 보지 않기 등등..

#### 🐶 세션이란
- 일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시켜줄때 사용한다.
- 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다.
- 세션은 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.
- 브라우저를 닫고나, 서버에서 세션을 삭제했을때만 삭제가 되므로, 쿠키보다 비교적 보안이 좋다.
- 사용 예시로 로그인을 유지되게 해줄 수 있다.
- [참고](https://hahahoho5915.tistory.com/32)

### 🎈 브라우저 렌더링 과정을 설명해보세요.
- 렌더링이란 HTML, CSS, JavaScript등의 파일을 브라우저가 화면에 표시할 수 있도록 변환하여 픽셀 단위로 나타내는것.
- 기본 렌더링 엔진의 동작 과정

> 1. HTML 문서를 파싱 하여 DOM 트리를 만들고, CSS 문서를 파싱 하여 CSSOM 트리를 만든다.
> 2. DOM과 CSSOM을 이용하여 렌더 트리를 만든다.
> 3. 렌더 트리 생성이 끝나면 Layout이 시작된다. 이 과정은 각 노드가 화면에 정확한 위치에 표시하기 위해 위치와 크기를 계산하는 과정이다.
> 4. 계산된 위치와 크기 등의 스타일들이 실제 픽셀로 표현하는 과정이 시작된다. 이 과정을 Paint라고 한다.
>
> - DOM, CSSOM 트리 구축 -> Render 트리 구축 -> Render 트리 배치 -> Render 트리 그리기

- https://beomy.github.io/tech/browser/browser-rendering/
- https://boxfoxs.tistory.com/408


## 📚 React
### 🎈 리액트의 상태관리에 대해서 경험과 더불어 설명하라.
- `state`를 `props`로 넘겨주면서 `data`를 관리할 수 있지만, 애플리케이션의 규모가 복잡해지고 커질수록 이는 힘들어진다. 단순히 `props`로 전달하기 위해 뎁스를 길게 하면 할 수록 쓸데없는 렌더링만 낳게 된다. 따라서 `state`를 전역적으로 관리하여, 해당 `state`를 사용하는 컴포넌트에서만 셀렉트하여 효율적으로 사용하기 위해 상태관리는 꼭 필요하다.
- React에서 상태관리로는 Redux와 Recoil를 사용해본 경험이 있다.
- Restful API와 통신을 통해 주고 받은 데이터들을 반영하여 `state`를 관리할 때 Redux와 Recoil를 사용하였다. 리덕스에서 제너레이터 기반의 리덕스 사가와 thunk를 이용하여 api call에 대한 비동기 로직 처리를 한 경험도 있다.
- 리덕스 상태관리 라이브러리 같은 경우 기본적인 store 구성을 위해 많은 보일러 플레이트와 장황한 코드를 작성해야 한다. 또한, 하나의 동작을 위해 다수의 액션과 이를 위한 로직이 필요하다.
- 그리고 비동기 데이터 처리 또는 계산된 값 캐시와 같은 중요한 기능은 라이브러리의 기능이 아니며, 이를 해결하기 위해 또 다른 라이브러리를 사용해야 한다.
- 리액트에서 제공하는 Context API의 경우에는 Provider가 조금이라도 변경이 된다면, 그 context를 구독하는 하위 요소들이 모두 리렌더링된다는 문제가 있다.
- 그래서 보다 compact한 Recoil을 사용해보았고 데이터를 아톰단위로 선언하고 useState를 Recoil의 useRecoilState를 사용해 보다 간편한 상태관리가 가능했다. 또한, 컴포넌트가 사용하는 데이터 조각만 사용할 수 있고, 계산된 selector를 선언할 수 있으며, 비동기 데이터 흐름을 위한 내장 솔루션까지 제공하여 redux에서 thunk나 saga와 같은 서드파티 라이브러리를 미들웨어로 추가를 안시켜도 된다는 장점을 느꼈다.
- [참고](https://ui.toast.com/weekly-pick/ko_20200616)

### 🎈 Redux-thunk와 Redux-saga를 비교해보세요.
- thunk와 saga는 리덕스 미들웨어이며 비동기 데이터 흐름을 보다 쉽게 테스트 할 수 있다.
- thunk는 절대로 action에 응답을 줄 수 없다. thunk의 로직은 함수 내부에 포함되어 있다. thunk를 사용하면 액션 객체가 아닌 함수를 디스패치 할 수 있다.
- redux-saga는 제너레이터로 구현되어 있으며, store를 구독하고 특정 작업이 디스패치될 때 saga가 실행되도록 유발할 수 있다.
- https://velog.io/@dongwon2/Redux-Thunk-vs-Redux-Saga%EB%A5%BC-%EB%B9%84%EA%B5%90%ED%95%B4-%EB%B4%85%EC%8B%9C%EB%8B%A4-
- https://velog.io/@bangina/Redux-Thunk-vs-Redux-Saga-%ED%95%9C%EA%B5%AD%EC%96%B4

### 🎈 React에서 컴포넌트 배열을 렌더링할 때 key를 사용하는 이유를 설명해보세요.
- key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕는다. key를 선택할 땐 해당 항목을 고유하게 식별할 수 있는 문자열을 사용하는 것이 좋다.
- DOM 노드의 자식들을 재귀적으로 처리할 떄, React는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경을 생성한다.
- 만약, key가 존재하지 않는 리스트에 두 개의 엘리먼트가 있고 맨 앞에 엘리먼트를 추가할 경우 기존에 존재하던 두 개의 엘리먼트를 그대로 유지하는 대신 모든 자식을 변경하게 된다. 따라서 비효율적인 문제가 발생할 수 있다.
- 이러한 문제를 해결하기 위해서 React에서 key 속성을 지원한다. 
- 만약 자식들이 key를 가지고 있다면, key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지를 확인한 후, 기존에 key를 가진 엘리먼트들은 그저 이동만 하면되고 새롭게 추가될 것이다.

#### 🐶 인덱스를 Key로 사용하면 안되는 이유
- 인덱스를 key로 사용 중 배열이 재배열되면 컴포넌트의 state와 관련된 문제가 발생할 수 있다.
- 컴포넌트 인스턴스는 key를 기반으로 갱신되고 재사용되는데 인덱스를 key로 사용하면 항목의 순서가 바뀌었을 때 key또한 변경될 것이다. 그 결과로, 컴포넌트의 state가 의도하지 않은 방식으로 바뀔 수도 있다. 
- 때문에 key는 반드시 변하지 않고, 예상 가능하며, 유일해야 한다.

#### 🐶 참고
- https://ko.reactjs.org/docs/lists-and-keys.html#keys
- https://ko.reactjs.org/docs/reconciliation.html#recursing-on-children
- https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318